image: golang:latest

workflow:
  rules:
    - if: $CI_COMMIT_TAG
    - if: $CI_COMMIT_BRANCH

variables:
  BASE_NAME: gatekeeper
  DOCKER_HUB: smokeycircles
  DOCKER_IMAGE: $DOCKER_HUB/$BASE_NAME

stages:
  - test
  - build_web
  - build_go
  - build_docker
  - distribute

# YAML Templates
.go_common: &go_common
  stage: build_go
  rules:
    - if: $CI_COMMIT_TAG
  tags:
    - shell

.build_template: &build_template
  <<: *go_common
  script:
    - make build-pipeline
  artifacts:
    paths:
      - bin/
      - internal/web/ui/dist/
    expire_in: 2days

# Jobs
test:
  <<: *go_common
  stage: test
  rules:
    - if: $CI_COMMIT_TAG
    - if: $CI_COMMIT_BRANCH
  script:
    - make test-report
  artifacts:
    when: always
    reports:
      junit:
        - dhcp-test-report.xml
        - dns-test-report.xml
    expire_in: 1year

build_web:
  stage: build_web
  rules:
    - if: $CI_COMMIT_TAG
  script:
    - make web
  artifacts:
    paths:
      - internal/web/ui/dist
    expire_in: 2days
  tags:
    - shell

test-coverage:
  <<: *go_common
  stage: test
  rules:
    - if: $CI_COMMIT_TAG
    - if: $CI_COMMIT_BRANCH
  script:
    - go mod download
    - go test -coverprofile=coverage.out -coverpkg=./... ./...
    - go tool cover -func=coverage.out | tail -1 | awk '{print "Coverage: " $3}'
    - go tool cover -func=coverage.out | tail -1 | awk '{print $3}' | sed 's/%//' > coverage.txt
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
    paths:
      - coverage.out
      - coverage.txt
  coverage: '/Coverage: \d+\.\d+%/'

# Build matrix using templates - Linux architectures
build_amd64_linux:
  <<: *build_template
  variables:
    GOARCH: amd64
    GOOS: linux
    BIN_NAME: $BASE_NAME-amd64

build_amd64_windows:
  <<: *build_template
  variables:
    GOARCH: amd64
    GOOS: windows
    BIN_NAME: $BASE_NAME-amd64.exe

build_arm_linux:
  <<: *build_template
  variables:
    GOARCH: arm
    GOOS: linux
    GOARM: "7"
    BIN_NAME: $BASE_NAME-arm

build_arm64_linux:
  <<: *build_template
  variables:
    GOARCH: arm64
    GOOS: linux
    BIN_NAME: $BASE_NAME-arm64

build_386_linux:
  <<: *build_template
  variables:
    GOARCH: "386"
    GOOS: linux
    BIN_NAME: $BASE_NAME-i386

# Single architecture Docker build (existing)
build_docker:
  variables:
    GOARCH: amd64
    GOOS: linux
    BIN_NAME: $BASE_NAME-amd64
  stage: build_docker
  rules:
    - if: $CI_COMMIT_TAG
  script:
    - make BIN_NAME=$BIN_NAME docker
  tags:
    - shell

# Multi-architecture Docker build
build_docker_multiarch:
  stage: build_docker
  rules:
    - if: $CI_COMMIT_TAG
  dependencies:
    - build_web
    - build_amd64_linux
    - build_arm_linux
    - build_arm64_linux
    - build_386_linux
  script:
    # Enable docker buildx
    - docker run --rm --privileged multiarch/qemu-user-static --reset -p yes
    - docker buildx create --use --name multiarch-builder --driver docker-container || docker buildx use multiarch-builder
    # Login to Docker Hub
    - echo $DOCKER_HUB_PASSWORD | docker login -u $DOCKER_HUB_USERNAME --password-stdin
    # Rename binaries to match expected naming convention for multiarch Dockerfile
    - mv bin/$BASE_NAME-amd64 bin/$BASE_NAME-linux-amd64
    - mv bin/$BASE_NAME-arm64 bin/$BASE_NAME-linux-arm64
    - mv bin/$BASE_NAME-arm bin/$BASE_NAME-linux-arm
    - mv bin/$BASE_NAME-i386 bin/$BASE_NAME-linux-386
    # Build and push multi-arch image
    - docker buildx build --platform linux/amd64,linux/arm64,linux/arm/v7,linux/386 --push -t $DOCKER_IMAGE:$CI_COMMIT_TAG -t $DOCKER_IMAGE:latest -f Dockerfile.multiarch .
  tags:
    - shell

s3_upload:
  stage: distribute
  rules:
    - if: $CI_COMMIT_TAG
  script:
    - aws s3 sync bin s3://gatekeeper-dist/$CI_COMMIT_TAG
  tags:
    - aws
